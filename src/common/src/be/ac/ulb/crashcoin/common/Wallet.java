package be.ac.ulb.crashcoin.common;

import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.PublicKey;

import be.ac.ulb.crashcoin.common.utils.Cryptography;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.security.InvalidAlgorithmParameterException;
import java.security.spec.InvalidKeySpecException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;

public class Wallet {

    protected PublicKey publicKey;
    private final File file;

    /**
     * Constructs an empty wallet. This constructor behaves differently if one
     * passes a Keypair to it.
     * 
     * @param f file that contains the wallet data
     */
    public Wallet(final File f) {
        file = f;
    }
    
    protected void actOnCorrectAuthentication() {
        Logger.getLogger(getClass().getName()).info("Authentication completed");
    }
    
    public void readWalletFile(final String walletPath, final String userPassword) throws FileNotFoundException,
            IOException, ClassNotFoundException, InvalidKeySpecException,
            InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException {
        this.readWalletFile(new File(walletPath), userPassword.toCharArray());
    }

    protected boolean readWalletFile(final File f, final char[] userPassword) throws FileNotFoundException,
            IOException, ClassNotFoundException, InvalidKeySpecException,
            InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException {
        boolean allIsOk = false;
        final WalletInformation walletInformation;
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(f))) {
            walletInformation = (WalletInformation) ois.readObject();
        } catch(IOException ex) {
            Logger.getLogger(getClass().getName()).log(Level.SEVERE, "Error with file {0}", ex.getMessage());
            return allIsOk;
        }

        // Retrieve wallet information stored on disk
        final byte[] salt = walletInformation.getSalt();
        final byte[] iv = walletInformation.getIv();
        final byte[] encryptedPrivateKey = walletInformation.getEncryptedPrivateKey();
        final byte[] publicKeyBytes = walletInformation.getPublicKey();

        final SecretKey decryptionKey = Cryptography.computeSecretKey(userPassword, salt);

        // Decrypt the private key with the decryption key generated from the user password
        // Initialize a cipher to the decryption mode with the decryptionKey
        final Cipher cipher = Cryptography.getCipher();
        cipher.init(Cipher.DECRYPT_MODE, decryptionKey, new IvParameterSpec(iv));

        // Decrypt the private key
        try {

            final byte[] privateKeyBytes = cipher.doFinal(encryptedPrivateKey);

            // Create a PairKey with the encoded public and private keys
            final KeyPair keyPair = Cryptography.createKeyPairFromEncodedKeys(publicKeyBytes, privateKeyBytes);

            // Verify the private key generated by the password entered by the user
            if (Cryptography.verifyPrivateKey(keyPair)) {
                this.publicKey = keyPair.getPublic();
                this.actOnCorrectAuthentication();
                allIsOk = true;

            } else {
                System.out.println("The password you entered is incorrect");
            }

        } catch (BadPaddingException e) {

            /*
            * Normally raised by the line:
            *  
            * byte[] privateKeyBytes = cipher.doFinal(encryptedPrivateKey);
            * 
            * In case of a wrong passowrd.
            * 
            * PKCS 5 Padding has a specific structure preventing the decryption
            * to complete with the wrong key (raising a BadPaddingException)
            * It's a sane check but not secure enough. If by chance the wrong
            * password produce the same PKCS5 padding as the right one, no
            * exception will be raised. The safety check can't then rely solely
            * on a bad padding exception.            	 * 
            * 
            * A second test with the public will be performed afterward to ensure
            * that the private key is indeed the right one (see hereunder).
            * 
             */
            System.out.println("The password you entered is incorrect");
        }
        return allIsOk;
    }
    
//    public boolean signTransaction(final String password) {
//        
//    }
    
    /**
     * Get the unique public key
     *
     * @return The public key
     */
    public PublicKey getPublicKey() {
        return publicKey;
    }
    
    public Address getAddress() {
        return new Address(publicKey);
    }
    
}
